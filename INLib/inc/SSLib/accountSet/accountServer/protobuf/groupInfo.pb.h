// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: groupInfo.proto

#ifndef PROTOBUF_groupInfo_2eproto__INCLUDED
#define PROTOBUF_groupInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "baseDef.pb.h"
// @@protoc_insertion_point(includes)

namespace PTBuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_groupInfo_2eproto();
void protobuf_AssignDesc_groupInfo_2eproto();
void protobuf_ShutdownFile_groupInfo_2eproto();

class CGroupInfo;
class CGroupInfo_AccountID;
class CGroupInfo_GroupType;
class CGroupInfo_GroupState;
class CGroupInfo_Permission;
class CGroupInfo_Members;
class CGroupInfoList;

// ===================================================================

class CGroupInfo : public ::google::protobuf::Message {
 public:
  CGroupInfo();
  virtual ~CGroupInfo();

  CGroupInfo(const CGroupInfo& from);

  inline CGroupInfo& operator=(const CGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGroupInfo& default_instance();

  void Swap(CGroupInfo* other);

  // implements Message ----------------------------------------------

  CGroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGroupInfo& from);
  void MergeFrom(const CGroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 GroupID = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 1;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // optional string GroupName = 2;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional uint64 AccountID = 3;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIDFieldNumber = 3;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional uint32 GroupType = 4;
  inline bool has_grouptype() const;
  inline void clear_grouptype();
  static const int kGroupTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 grouptype() const;
  inline void set_grouptype(::google::protobuf::uint32 value);

  // optional uint32 GroupState = 5;
  inline bool has_groupstate() const;
  inline void clear_groupstate();
  static const int kGroupStateFieldNumber = 5;
  inline ::google::protobuf::uint32 groupstate() const;
  inline void set_groupstate(::google::protobuf::uint32 value);

  // optional string Permission = 6;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 6;
  inline const ::std::string& permission() const;
  inline void set_permission(const ::std::string& value);
  inline void set_permission(const char* value);
  inline void set_permission(const char* value, size_t size);
  inline ::std::string* mutable_permission();
  inline ::std::string* release_permission();
  inline void set_allocated_permission(::std::string* permission);

  // optional string Members = 7;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 7;
  inline const ::std::string& members() const;
  inline void set_members(const ::std::string& value);
  inline void set_members(const char* value);
  inline void set_members(const char* value, size_t size);
  inline ::std::string* mutable_members();
  inline ::std::string* release_members();
  inline void set_allocated_members(::std::string* members);

  // optional string ModifyTime = 8;
  inline bool has_modifytime() const;
  inline void clear_modifytime();
  static const int kModifyTimeFieldNumber = 8;
  inline const ::std::string& modifytime() const;
  inline void set_modifytime(const ::std::string& value);
  inline void set_modifytime(const char* value);
  inline void set_modifytime(const char* value, size_t size);
  inline ::std::string* mutable_modifytime();
  inline ::std::string* release_modifytime();
  inline void set_allocated_modifytime(::std::string* modifytime);

  // @@protoc_insertion_point(class_scope:PTBuf.CGroupInfo)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_grouptype();
  inline void clear_has_grouptype();
  inline void set_has_groupstate();
  inline void clear_has_groupstate();
  inline void set_has_permission();
  inline void clear_has_permission();
  inline void set_has_members();
  inline void clear_has_members();
  inline void set_has_modifytime();
  inline void clear_has_modifytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 groupid_;
  ::std::string* groupname_;
  ::google::protobuf::uint64 accountid_;
  ::google::protobuf::uint32 grouptype_;
  ::google::protobuf::uint32 groupstate_;
  ::std::string* permission_;
  ::std::string* members_;
  ::std::string* modifytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_groupInfo_2eproto();
  friend void protobuf_AssignDesc_groupInfo_2eproto();
  friend void protobuf_ShutdownFile_groupInfo_2eproto();

  void InitAsDefaultInstance();
  static CGroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class CGroupInfo_AccountID : public ::google::protobuf::Message {
 public:
  CGroupInfo_AccountID();
  virtual ~CGroupInfo_AccountID();

  CGroupInfo_AccountID(const CGroupInfo_AccountID& from);

  inline CGroupInfo_AccountID& operator=(const CGroupInfo_AccountID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGroupInfo_AccountID& default_instance();

  void Swap(CGroupInfo_AccountID* other);

  // implements Message ----------------------------------------------

  CGroupInfo_AccountID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGroupInfo_AccountID& from);
  void MergeFrom(const CGroupInfo_AccountID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GroupName = 1;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional uint64 AccountID = 2;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIDFieldNumber = 2;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PTBuf.CGroupInfo_AccountID)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_accountid();
  inline void clear_has_accountid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupname_;
  ::google::protobuf::uint64 accountid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_groupInfo_2eproto();
  friend void protobuf_AssignDesc_groupInfo_2eproto();
  friend void protobuf_ShutdownFile_groupInfo_2eproto();

  void InitAsDefaultInstance();
  static CGroupInfo_AccountID* default_instance_;
};
// -------------------------------------------------------------------

class CGroupInfo_GroupType : public ::google::protobuf::Message {
 public:
  CGroupInfo_GroupType();
  virtual ~CGroupInfo_GroupType();

  CGroupInfo_GroupType(const CGroupInfo_GroupType& from);

  inline CGroupInfo_GroupType& operator=(const CGroupInfo_GroupType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGroupInfo_GroupType& default_instance();

  void Swap(CGroupInfo_GroupType* other);

  // implements Message ----------------------------------------------

  CGroupInfo_GroupType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGroupInfo_GroupType& from);
  void MergeFrom(const CGroupInfo_GroupType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GroupName = 1;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional uint32 GroupType = 2;
  inline bool has_grouptype() const;
  inline void clear_grouptype();
  static const int kGroupTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 grouptype() const;
  inline void set_grouptype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PTBuf.CGroupInfo_GroupType)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_grouptype();
  inline void clear_has_grouptype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupname_;
  ::google::protobuf::uint32 grouptype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_groupInfo_2eproto();
  friend void protobuf_AssignDesc_groupInfo_2eproto();
  friend void protobuf_ShutdownFile_groupInfo_2eproto();

  void InitAsDefaultInstance();
  static CGroupInfo_GroupType* default_instance_;
};
// -------------------------------------------------------------------

class CGroupInfo_GroupState : public ::google::protobuf::Message {
 public:
  CGroupInfo_GroupState();
  virtual ~CGroupInfo_GroupState();

  CGroupInfo_GroupState(const CGroupInfo_GroupState& from);

  inline CGroupInfo_GroupState& operator=(const CGroupInfo_GroupState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGroupInfo_GroupState& default_instance();

  void Swap(CGroupInfo_GroupState* other);

  // implements Message ----------------------------------------------

  CGroupInfo_GroupState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGroupInfo_GroupState& from);
  void MergeFrom(const CGroupInfo_GroupState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GroupName = 1;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional uint32 GroupState = 2;
  inline bool has_groupstate() const;
  inline void clear_groupstate();
  static const int kGroupStateFieldNumber = 2;
  inline ::google::protobuf::uint32 groupstate() const;
  inline void set_groupstate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PTBuf.CGroupInfo_GroupState)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_groupstate();
  inline void clear_has_groupstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupname_;
  ::google::protobuf::uint32 groupstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_groupInfo_2eproto();
  friend void protobuf_AssignDesc_groupInfo_2eproto();
  friend void protobuf_ShutdownFile_groupInfo_2eproto();

  void InitAsDefaultInstance();
  static CGroupInfo_GroupState* default_instance_;
};
// -------------------------------------------------------------------

class CGroupInfo_Permission : public ::google::protobuf::Message {
 public:
  CGroupInfo_Permission();
  virtual ~CGroupInfo_Permission();

  CGroupInfo_Permission(const CGroupInfo_Permission& from);

  inline CGroupInfo_Permission& operator=(const CGroupInfo_Permission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGroupInfo_Permission& default_instance();

  void Swap(CGroupInfo_Permission* other);

  // implements Message ----------------------------------------------

  CGroupInfo_Permission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGroupInfo_Permission& from);
  void MergeFrom(const CGroupInfo_Permission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GroupName = 1;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional string Permission = 2;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 2;
  inline const ::std::string& permission() const;
  inline void set_permission(const ::std::string& value);
  inline void set_permission(const char* value);
  inline void set_permission(const char* value, size_t size);
  inline ::std::string* mutable_permission();
  inline ::std::string* release_permission();
  inline void set_allocated_permission(::std::string* permission);

  // @@protoc_insertion_point(class_scope:PTBuf.CGroupInfo_Permission)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_permission();
  inline void clear_has_permission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupname_;
  ::std::string* permission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_groupInfo_2eproto();
  friend void protobuf_AssignDesc_groupInfo_2eproto();
  friend void protobuf_ShutdownFile_groupInfo_2eproto();

  void InitAsDefaultInstance();
  static CGroupInfo_Permission* default_instance_;
};
// -------------------------------------------------------------------

class CGroupInfo_Members : public ::google::protobuf::Message {
 public:
  CGroupInfo_Members();
  virtual ~CGroupInfo_Members();

  CGroupInfo_Members(const CGroupInfo_Members& from);

  inline CGroupInfo_Members& operator=(const CGroupInfo_Members& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGroupInfo_Members& default_instance();

  void Swap(CGroupInfo_Members* other);

  // implements Message ----------------------------------------------

  CGroupInfo_Members* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGroupInfo_Members& from);
  void MergeFrom(const CGroupInfo_Members& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GroupName = 1;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional string Members = 2;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::std::string& members() const;
  inline void set_members(const ::std::string& value);
  inline void set_members(const char* value);
  inline void set_members(const char* value, size_t size);
  inline ::std::string* mutable_members();
  inline ::std::string* release_members();
  inline void set_allocated_members(::std::string* members);

  // @@protoc_insertion_point(class_scope:PTBuf.CGroupInfo_Members)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_members();
  inline void clear_has_members();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupname_;
  ::std::string* members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_groupInfo_2eproto();
  friend void protobuf_AssignDesc_groupInfo_2eproto();
  friend void protobuf_ShutdownFile_groupInfo_2eproto();

  void InitAsDefaultInstance();
  static CGroupInfo_Members* default_instance_;
};
// -------------------------------------------------------------------

class CGroupInfoList : public ::google::protobuf::Message {
 public:
  CGroupInfoList();
  virtual ~CGroupInfoList();

  CGroupInfoList(const CGroupInfoList& from);

  inline CGroupInfoList& operator=(const CGroupInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGroupInfoList& default_instance();

  void Swap(CGroupInfoList* other);

  // implements Message ----------------------------------------------

  CGroupInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGroupInfoList& from);
  void MergeFrom(const CGroupInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PTBuf.CGroupInfo Objects = 1;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 1;
  inline const ::PTBuf::CGroupInfo& objects(int index) const;
  inline ::PTBuf::CGroupInfo* mutable_objects(int index);
  inline ::PTBuf::CGroupInfo* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::PTBuf::CGroupInfo >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::PTBuf::CGroupInfo >*
      mutable_objects();

  // @@protoc_insertion_point(class_scope:PTBuf.CGroupInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PTBuf::CGroupInfo > objects_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_groupInfo_2eproto();
  friend void protobuf_AssignDesc_groupInfo_2eproto();
  friend void protobuf_ShutdownFile_groupInfo_2eproto();

  void InitAsDefaultInstance();
  static CGroupInfoList* default_instance_;
};
// ===================================================================


// ===================================================================

// CGroupInfo

// optional uint64 GroupID = 1;
inline bool CGroupInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGroupInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGroupInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGroupInfo::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 CGroupInfo::groupid() const {
  return groupid_;
}
inline void CGroupInfo::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional string GroupName = 2;
inline bool CGroupInfo::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGroupInfo::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGroupInfo::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGroupInfo::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CGroupInfo::groupname() const {
  return *groupname_;
}
inline void CGroupInfo::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CGroupInfo::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 AccountID = 3;
inline bool CGroupInfo::has_accountid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGroupInfo::set_has_accountid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGroupInfo::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGroupInfo::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 CGroupInfo::accountid() const {
  return accountid_;
}
inline void CGroupInfo::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional uint32 GroupType = 4;
inline bool CGroupInfo::has_grouptype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGroupInfo::set_has_grouptype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGroupInfo::clear_has_grouptype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGroupInfo::clear_grouptype() {
  grouptype_ = 0u;
  clear_has_grouptype();
}
inline ::google::protobuf::uint32 CGroupInfo::grouptype() const {
  return grouptype_;
}
inline void CGroupInfo::set_grouptype(::google::protobuf::uint32 value) {
  set_has_grouptype();
  grouptype_ = value;
}

// optional uint32 GroupState = 5;
inline bool CGroupInfo::has_groupstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGroupInfo::set_has_groupstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGroupInfo::clear_has_groupstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGroupInfo::clear_groupstate() {
  groupstate_ = 0u;
  clear_has_groupstate();
}
inline ::google::protobuf::uint32 CGroupInfo::groupstate() const {
  return groupstate_;
}
inline void CGroupInfo::set_groupstate(::google::protobuf::uint32 value) {
  set_has_groupstate();
  groupstate_ = value;
}

// optional string Permission = 6;
inline bool CGroupInfo::has_permission() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGroupInfo::set_has_permission() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGroupInfo::clear_has_permission() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGroupInfo::clear_permission() {
  if (permission_ != &::google::protobuf::internal::kEmptyString) {
    permission_->clear();
  }
  clear_has_permission();
}
inline const ::std::string& CGroupInfo::permission() const {
  return *permission_;
}
inline void CGroupInfo::set_permission(const ::std::string& value) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(value);
}
inline void CGroupInfo::set_permission(const char* value) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(value);
}
inline void CGroupInfo::set_permission(const char* value, size_t size) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo::mutable_permission() {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  return permission_;
}
inline ::std::string* CGroupInfo::release_permission() {
  clear_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = permission_;
    permission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo::set_allocated_permission(::std::string* permission) {
  if (permission_ != &::google::protobuf::internal::kEmptyString) {
    delete permission_;
  }
  if (permission) {
    set_has_permission();
    permission_ = permission;
  } else {
    clear_has_permission();
    permission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Members = 7;
inline bool CGroupInfo::has_members() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGroupInfo::set_has_members() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGroupInfo::clear_has_members() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGroupInfo::clear_members() {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    members_->clear();
  }
  clear_has_members();
}
inline const ::std::string& CGroupInfo::members() const {
  return *members_;
}
inline void CGroupInfo::set_members(const ::std::string& value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void CGroupInfo::set_members(const char* value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void CGroupInfo::set_members(const char* value, size_t size) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo::mutable_members() {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  return members_;
}
inline ::std::string* CGroupInfo::release_members() {
  clear_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = members_;
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo::set_allocated_members(::std::string* members) {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    delete members_;
  }
  if (members) {
    set_has_members();
    members_ = members;
  } else {
    clear_has_members();
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ModifyTime = 8;
inline bool CGroupInfo::has_modifytime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CGroupInfo::set_has_modifytime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CGroupInfo::clear_has_modifytime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CGroupInfo::clear_modifytime() {
  if (modifytime_ != &::google::protobuf::internal::kEmptyString) {
    modifytime_->clear();
  }
  clear_has_modifytime();
}
inline const ::std::string& CGroupInfo::modifytime() const {
  return *modifytime_;
}
inline void CGroupInfo::set_modifytime(const ::std::string& value) {
  set_has_modifytime();
  if (modifytime_ == &::google::protobuf::internal::kEmptyString) {
    modifytime_ = new ::std::string;
  }
  modifytime_->assign(value);
}
inline void CGroupInfo::set_modifytime(const char* value) {
  set_has_modifytime();
  if (modifytime_ == &::google::protobuf::internal::kEmptyString) {
    modifytime_ = new ::std::string;
  }
  modifytime_->assign(value);
}
inline void CGroupInfo::set_modifytime(const char* value, size_t size) {
  set_has_modifytime();
  if (modifytime_ == &::google::protobuf::internal::kEmptyString) {
    modifytime_ = new ::std::string;
  }
  modifytime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo::mutable_modifytime() {
  set_has_modifytime();
  if (modifytime_ == &::google::protobuf::internal::kEmptyString) {
    modifytime_ = new ::std::string;
  }
  return modifytime_;
}
inline ::std::string* CGroupInfo::release_modifytime() {
  clear_has_modifytime();
  if (modifytime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modifytime_;
    modifytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo::set_allocated_modifytime(::std::string* modifytime) {
  if (modifytime_ != &::google::protobuf::internal::kEmptyString) {
    delete modifytime_;
  }
  if (modifytime) {
    set_has_modifytime();
    modifytime_ = modifytime;
  } else {
    clear_has_modifytime();
    modifytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CGroupInfo_AccountID

// optional string GroupName = 1;
inline bool CGroupInfo_AccountID::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGroupInfo_AccountID::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGroupInfo_AccountID::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGroupInfo_AccountID::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CGroupInfo_AccountID::groupname() const {
  return *groupname_;
}
inline void CGroupInfo_AccountID::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_AccountID::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_AccountID::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo_AccountID::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CGroupInfo_AccountID::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo_AccountID::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 AccountID = 2;
inline bool CGroupInfo_AccountID::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGroupInfo_AccountID::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGroupInfo_AccountID::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGroupInfo_AccountID::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 CGroupInfo_AccountID::accountid() const {
  return accountid_;
}
inline void CGroupInfo_AccountID::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// -------------------------------------------------------------------

// CGroupInfo_GroupType

// optional string GroupName = 1;
inline bool CGroupInfo_GroupType::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGroupInfo_GroupType::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGroupInfo_GroupType::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGroupInfo_GroupType::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CGroupInfo_GroupType::groupname() const {
  return *groupname_;
}
inline void CGroupInfo_GroupType::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_GroupType::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_GroupType::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo_GroupType::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CGroupInfo_GroupType::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo_GroupType::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 GroupType = 2;
inline bool CGroupInfo_GroupType::has_grouptype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGroupInfo_GroupType::set_has_grouptype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGroupInfo_GroupType::clear_has_grouptype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGroupInfo_GroupType::clear_grouptype() {
  grouptype_ = 0u;
  clear_has_grouptype();
}
inline ::google::protobuf::uint32 CGroupInfo_GroupType::grouptype() const {
  return grouptype_;
}
inline void CGroupInfo_GroupType::set_grouptype(::google::protobuf::uint32 value) {
  set_has_grouptype();
  grouptype_ = value;
}

// -------------------------------------------------------------------

// CGroupInfo_GroupState

// optional string GroupName = 1;
inline bool CGroupInfo_GroupState::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGroupInfo_GroupState::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGroupInfo_GroupState::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGroupInfo_GroupState::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CGroupInfo_GroupState::groupname() const {
  return *groupname_;
}
inline void CGroupInfo_GroupState::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_GroupState::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_GroupState::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo_GroupState::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CGroupInfo_GroupState::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo_GroupState::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 GroupState = 2;
inline bool CGroupInfo_GroupState::has_groupstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGroupInfo_GroupState::set_has_groupstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGroupInfo_GroupState::clear_has_groupstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGroupInfo_GroupState::clear_groupstate() {
  groupstate_ = 0u;
  clear_has_groupstate();
}
inline ::google::protobuf::uint32 CGroupInfo_GroupState::groupstate() const {
  return groupstate_;
}
inline void CGroupInfo_GroupState::set_groupstate(::google::protobuf::uint32 value) {
  set_has_groupstate();
  groupstate_ = value;
}

// -------------------------------------------------------------------

// CGroupInfo_Permission

// optional string GroupName = 1;
inline bool CGroupInfo_Permission::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGroupInfo_Permission::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGroupInfo_Permission::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGroupInfo_Permission::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CGroupInfo_Permission::groupname() const {
  return *groupname_;
}
inline void CGroupInfo_Permission::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_Permission::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_Permission::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo_Permission::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CGroupInfo_Permission::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo_Permission::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Permission = 2;
inline bool CGroupInfo_Permission::has_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGroupInfo_Permission::set_has_permission() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGroupInfo_Permission::clear_has_permission() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGroupInfo_Permission::clear_permission() {
  if (permission_ != &::google::protobuf::internal::kEmptyString) {
    permission_->clear();
  }
  clear_has_permission();
}
inline const ::std::string& CGroupInfo_Permission::permission() const {
  return *permission_;
}
inline void CGroupInfo_Permission::set_permission(const ::std::string& value) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(value);
}
inline void CGroupInfo_Permission::set_permission(const char* value) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(value);
}
inline void CGroupInfo_Permission::set_permission(const char* value, size_t size) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo_Permission::mutable_permission() {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  return permission_;
}
inline ::std::string* CGroupInfo_Permission::release_permission() {
  clear_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = permission_;
    permission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo_Permission::set_allocated_permission(::std::string* permission) {
  if (permission_ != &::google::protobuf::internal::kEmptyString) {
    delete permission_;
  }
  if (permission) {
    set_has_permission();
    permission_ = permission;
  } else {
    clear_has_permission();
    permission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CGroupInfo_Members

// optional string GroupName = 1;
inline bool CGroupInfo_Members::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGroupInfo_Members::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGroupInfo_Members::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGroupInfo_Members::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CGroupInfo_Members::groupname() const {
  return *groupname_;
}
inline void CGroupInfo_Members::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_Members::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CGroupInfo_Members::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo_Members::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CGroupInfo_Members::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo_Members::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Members = 2;
inline bool CGroupInfo_Members::has_members() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGroupInfo_Members::set_has_members() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGroupInfo_Members::clear_has_members() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGroupInfo_Members::clear_members() {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    members_->clear();
  }
  clear_has_members();
}
inline const ::std::string& CGroupInfo_Members::members() const {
  return *members_;
}
inline void CGroupInfo_Members::set_members(const ::std::string& value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void CGroupInfo_Members::set_members(const char* value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void CGroupInfo_Members::set_members(const char* value, size_t size) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGroupInfo_Members::mutable_members() {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  return members_;
}
inline ::std::string* CGroupInfo_Members::release_members() {
  clear_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = members_;
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGroupInfo_Members::set_allocated_members(::std::string* members) {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    delete members_;
  }
  if (members) {
    set_has_members();
    members_ = members;
  } else {
    clear_has_members();
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CGroupInfoList

// repeated .PTBuf.CGroupInfo Objects = 1;
inline int CGroupInfoList::objects_size() const {
  return objects_.size();
}
inline void CGroupInfoList::clear_objects() {
  objects_.Clear();
}
inline const ::PTBuf::CGroupInfo& CGroupInfoList::objects(int index) const {
  return objects_.Get(index);
}
inline ::PTBuf::CGroupInfo* CGroupInfoList::mutable_objects(int index) {
  return objects_.Mutable(index);
}
inline ::PTBuf::CGroupInfo* CGroupInfoList::add_objects() {
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PTBuf::CGroupInfo >&
CGroupInfoList::objects() const {
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::PTBuf::CGroupInfo >*
CGroupInfoList::mutable_objects() {
  return &objects_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PTBuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_groupInfo_2eproto__INCLUDED
